<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>デジタル神経衰弱</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Google Fontsからポップなフォントを読み込む */
        @import url('https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&family=Zen+Maru+Gothic:wght@400;700&display=swap');
        
        :root {
            --c-bg: #fffbeb; /* Light Yellow */
            --c-cyan: #5fc1c7;
            --c-dark-blue: #1d4763;
            --c-black: #060500;
            --c-gray: #d1d5db; /* Tailwind gray-300 */
        }

        body {
            font-family: 'Zen Maru Gothic', sans-serif;
            background-color: var(--c-bg);
            color: var(--c-black);
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        h1, .font-pop {
            font-family: 'Mochiy Pop One', sans-serif;
        }

        .card {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .card.is-flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .card-face.card-back {
            transform: rotateY(180deg);
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body class="bg-[var(--c-bg)] text-[var(--c-black)]">

    <!-- ========== タイトル画面 ========== -->
    <div id="title-screen" class="w-full max-w-2xl mx-auto pt-8 pb-24 px-4 sm:px-8 text-center">
        <h1 class="text-4xl md:text-6xl text-[var(--c-dark-blue)] mb-8 drop-shadow-md">デジタル神経衰弱</h1>

        <!-- ステップ1: 画像選択 -->
        <div id="step1-container">
            <div id="image-selection-section" class="bg-white p-6 rounded-2xl shadow-lg border-2 border-[var(--c-dark-blue)]">
                <h2 class="text-xl font-bold mb-4 text-[var(--c-dark-blue)]">1. 画像を選ぶ</h2>
                <p class="text-sm text-gray-500 mb-4">使う画像を選択してください。<br>同じ画像が2枚で1ペアになります。</p>
                <div class="grid md:grid-cols-2 gap-4">
                    <label for="folder-input" class="w-full bg-[var(--c-cyan)] hover:brightness-95 text-white font-bold p-2 rounded-xl shadow-md cursor-pointer transition-transform transform hover:scale-105 h-20 flex flex-col justify-center items-center">
                        <span>フォルダでまとめて選択</span>
                    </label>
                    <input type="file" id="folder-input" webkitdirectory directory multiple>

                    <label for="files-input" class="w-full bg-[var(--c-cyan)] hover:brightness-95 text-white font-bold p-2 rounded-xl shadow-md cursor-pointer transition-transform transform hover:scale-105 h-20 flex flex-col justify-center items-center">
                        <span>1枚ずつ選択</span>
                    </label>
                    <input type="file" id="files-input" multiple accept="image/*">
                </div>
                 <div id="image-preview-area" class="flex flex-wrap justify-center gap-4 mt-6 hidden"></div>
                 <p id="image-info" class="text-gray-600 hidden mt-4"></p>
            </div>
            <div class="grid grid-cols-2 gap-4 mt-4">
                <div></div> <!-- 左側の空のセル -->
                <button id="confirm-images-btn" class="w-full bg-[var(--c-gray)] text-white font-bold p-3 rounded-xl shadow-md cursor-not-allowed transition-transform transform hover:scale-105" disabled>決定</button>
            </div>
        </div>
        
        <!-- ステップ2: 表示方法選択 -->
        <div id="step2-container" class="hidden">
            <div id="image-fit-selection" class="bg-white p-6 rounded-2xl shadow-lg border-2 border-[var(--c-dark-blue)]">
                <h2 class="text-xl font-bold mb-4 text-[var(--c-dark-blue)]">2. 画像の表示方法を選ぶ</h2>
                <p class="text-sm text-gray-500 mb-4">
                    トリミング: カードに合わせて拡大・縮小<br>
                    全体表示: 画像全体をカードに収める
                </p>
                <div class="flex justify-center gap-4">
                    <button id="fit-cover-btn" class="image-fit-btn w-1/2 bg-[var(--c-cyan)] text-white font-bold p-2 rounded-xl shadow-md transition-transform transform hover:scale-105 h-20 flex flex-col justify-center items-center">
                        トリミング
                    </button>
                    <button id="fit-contain-btn" class="image-fit-btn w-1/2 bg-[var(--c-gray)] text-white font-bold p-2 rounded-xl shadow-md transition-transform transform hover:scale-105 h-20 flex flex-col justify-center items-center">
                        全体表示
                    </button>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4 mt-4">
                <button id="back-to-step1-btn" class="w-full bg-[var(--c-gray)] hover:brightness-95 text-white font-bold p-3 rounded-xl shadow-md transition-transform transform hover:scale-105">戻る</button>
                <button id="confirm-fit-btn" class="w-full bg-[var(--c-dark-blue)] hover:brightness-95 text-white font-bold p-3 rounded-xl shadow-md transition-transform transform hover:scale-105">決定</button>
            </div>
        </div>

        <!-- ステップ3: 難易度選択 -->
        <div id="step3-container" class="hidden">
            <div id="difficulty-selection" class="bg-white p-6 rounded-2xl shadow-lg border-2 border-[var(--c-dark-blue)]">
                <h2 class="text-xl font-bold mb-4 text-[var(--c-dark-blue)]">3. 難易度を選ぶ</h2>
                <p class="text-sm text-gray-500 mb-4">
                    かんたん: 最初から全部見える<br>
                    むずかしい: 全部うら面から
                </p>
                <div class="flex justify-center gap-4">
                    <button id="easy-mode-btn" class="difficulty-btn w-1/2 bg-[var(--c-cyan)] text-white font-bold p-2 rounded-xl shadow-md transition-transform transform hover:scale-105 h-20 flex flex-col justify-center items-center">
                        かんたん
                    </button>
                    <button id="hard-mode-btn" class="difficulty-btn w-1/2 bg-[var(--c-gray)] text-white font-bold p-2 rounded-xl shadow-md transition-transform transform hover:scale-105 h-20 flex flex-col justify-center items-center">
                        むずかしい
                    </button>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4 mt-4">
                <button id="back-to-step2-btn" class="w-full bg-[var(--c-gray)] hover:brightness-95 text-white font-bold p-3 rounded-xl shadow-md transition-transform transform hover:scale-105">戻る</button>
                <button id="start-game-btn" class="w-full bg-[var(--c-dark-blue)] hover:brightness-95 text-white font-bold p-3 rounded-xl shadow-md transition-transform transform hover:scale-105">ゲーム開始</button>
            </div>
        </div>
    </div>

    <!-- ========== ゲーム画面 ========== -->
    <div id="game-screen" class="hidden w-full h-screen flex flex-col p-4 relative">
        <div class="flex justify-between items-start mb-2">
            <button id="back-to-title-btn" class="bg-[var(--c-dark-blue)] hover:brightness-95 text-white font-bold py-2 px-4 rounded-full shadow-md transition-transform transform hover:scale-105">
                タイトルに戻る
            </button>
            <div class="flex gap-2">
                <button id="zoom-out-btn" class="w-12 h-12 flex items-center justify-center bg-white hover:bg-gray-100 text-[var(--c-black)] font-bold rounded-full shadow-md transition-transform transform hover:scale-105">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7" /></svg>
                </button>
                <button id="zoom-in-btn" class="w-12 h-12 flex items-center justify-center bg-white hover:bg-gray-100 text-[var(--c-black)] font-bold rounded-full shadow-md transition-transform transform hover:scale-105">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" /></svg>
                </button>
            </div>
        </div>
        <div id="game-board-container" class="flex-grow flex items-center justify-center overflow-auto">
             <div id="game-board" class="grid gap-2 md:gap-4 p-4"></div>
        </div>
        <!-- ★★★ 修正点: アクションボタンを追加 ★★★ -->
        <div id="action-buttons" class="absolute bottom-8 left-1/2 -translate-x-1/2 flex gap-4 z-10">
            <button id="next-pair-btn" class="hidden bg-[var(--c-dark-blue)] text-white font-bold py-3 px-8 rounded-xl shadow-md transition-transform transform hover:scale-105">次へ</button>
            <button id="return-cards-btn" class="hidden bg-[var(--c-dark-blue)] text-white font-bold py-3 px-8 rounded-xl shadow-md transition-transform transform hover:scale-105">戻す</button>
        </div>
    </div>
    
    <div class="fixed bottom-4 left-4 z-10">
        <button id="mute-btn" class="w-14 h-14 flex items-center justify-center bg-[var(--c-dark-blue)] hover:brightness-95 text-white font-bold rounded-full shadow-lg transition-transform transform hover:scale-105">
            <svg id="sound-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg>
        </button>
    </div>
    
    <div id="clear-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
        <div class="bg-white p-10 rounded-3xl shadow-xl text-center transform scale-75 opacity-0 transition-all duration-300">
            <h2 class="font-pop text-5xl text-transparent bg-clip-text bg-gradient-to-r from-[var(--c-cyan)] to-[var(--c-dark-blue)] mb-6">CLEAR!</h2>
            <button id="back-to-title-from-clear-btn" class="bg-[var(--c-dark-blue)] hover:brightness-95 text-white font-bold py-3 px-8 rounded-full shadow-md transition-transform transform hover:scale-105">
                タイトルに戻る
            </button>
        </div>
    </div>

    <audio id="sfx-button" src="https://y-sensei-lab.github.io/memory-game/audio/sfx_button.mp3"></audio>
    <audio id="sfx-open" src="https://y-sensei-lab.github.io/memory-game/audio/sfx_open.mp3"></audio>
    <audio id="sfx-pair" src="https://y-sensei-lab.github.io/memory-game/audio/sfx_pair.mp3"></audio>
    <audio id="sfx-fail" src="https://y-sensei-lab.github.io/memory-game/audio/sfx_fail.mp3"></audio>
    <audio id="sfx-clear" src="https://y-sensei-lab.github.io/memory-game/audio/sfx_clear.mp3"></audio>


<script>
document.addEventListener('DOMContentLoaded', () => {

    // ========== DOM要素の取得 ==========
    const titleScreen = document.getElementById('title-screen');
    const gameScreen = document.getElementById('game-screen');
    const clearModal = document.getElementById('clear-modal');
    
    const step1Container = document.getElementById('step1-container');
    const step2Container = document.getElementById('step2-container');
    const step3Container = document.getElementById('step3-container');
    
    const folderInput = document.getElementById('folder-input');
    const filesInput = document.getElementById('files-input');
    const imagePreviewArea = document.getElementById('image-preview-area');
    const imageInfo = document.getElementById('image-info');
    const confirmImagesBtn = document.getElementById('confirm-images-btn');
    
    const fitCoverBtn = document.getElementById('fit-cover-btn');
    const fitContainBtn = document.getElementById('fit-contain-btn');
    const confirmFitBtn = document.getElementById('confirm-fit-btn');
    const backToStep1Btn = document.getElementById('back-to-step1-btn');
    
    const easyModeBtn = document.getElementById('easy-mode-btn');
    const hardModeBtn = document.getElementById('hard-mode-btn');
    const startGameBtn = document.getElementById('start-game-btn');
    const backToStep2Btn = document.getElementById('back-to-step2-btn');
    
    const gameBoard = document.getElementById('game-board');
    const backToTitleBtn = document.getElementById('back-to-title-btn');
    const backToTitleFromClearBtn = document.getElementById('back-to-title-from-clear-btn');
    
    const zoomInBtn = document.getElementById('zoom-in-btn');
    const zoomOutBtn = document.getElementById('zoom-out-btn');

    const muteBtn = document.getElementById('mute-btn');
    const nextPairBtn = document.getElementById('next-pair-btn');
    const returnCardsBtn = document.getElementById('return-cards-btn');
    
    const sfx = {
        button: document.getElementById('sfx-button'), open: document.getElementById('sfx-open'),
        pair: document.getElementById('sfx-pair'), fail: document.getElementById('sfx-fail'),
        clear: document.getElementById('sfx-clear'),
    };

    // ========== ゲームの状態管理 ==========
    let selectedImages = [];
    let imageFit = 'cover';
    let difficulty = 'easy';
    let firstCard = null, secondCard = null, lockBoard = false;
    let pairsFound = 0, totalPairs = 0, currentCardSize = 128;
    let isMuted = false;
    let audioUnlocked = false;

    // ========== 音量管理 ==========
    const toggleMute = () => {
        isMuted = !isMuted;
        Object.values(sfx).forEach(sound => {
            sound.muted = isMuted;
        });
        muteBtn.style.backgroundColor = isMuted ? 'var(--c-gray)' : 'var(--c-dark-blue)';
        localStorage.setItem('isMuted', isMuted);
    };

    const loadMuteState = () => {
        const storedMuteState = localStorage.getItem('isMuted') === 'true';
        if (storedMuteState) {
            isMuted = false;
            toggleMute();
        }
    };
    
    const playSfx = (sound) => {
        if (!isMuted && audioUnlocked) {
             const audio = new Audio(sound.src);
             audio.play().catch(e => console.error("SFX play error:", e));
        }
    };

    // ========== 画面・ステップ遷移 ==========
    const showScreen = (screen) => {
        titleScreen.classList.toggle('hidden', screen !== 'title');
        gameScreen.classList.toggle('hidden', screen !== 'game');
    };
    const showStep = (step) => {
        step1Container.classList.toggle('hidden', step !== 1);
        step2Container.classList.toggle('hidden', step !== 2);
        step3Container.classList.toggle('hidden', step !== 3);
    };
    
    const unlockAudio = () => {
        if (audioUnlocked) return;
        
        const allSounds = Object.values(sfx);
        allSounds.forEach(sound => {
            sound.volume = 0;
            const playPromise = sound.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {}).then(() => {
                    sound.pause();
                    sound.currentTime = 0;
                    sound.volume = 1; 
                });
            }
        });
        audioUnlocked = true;
        console.log("Audio Unlocked");
        document.body.removeEventListener('click', unlockAudio);
        document.body.removeEventListener('touchstart', unlockAudio);
    };
    
    // ========== 初期化処理 ==========
    const init = () => {
        showScreen('title');
        resetGameStates();
        loadMuteState();
        if (!audioUnlocked) {
            document.body.addEventListener('click', unlockAudio, { once: true });
            document.body.addEventListener('touchstart', unlockAudio, { once: true, passive: true });
        }
    };

    // ========== ステップ1: 画像選択処理 ==========
    const updateStep1ConfirmButtonState = () => {
        const isReady = selectedImages.length > 0;
        confirmImagesBtn.disabled = !isReady;
        confirmImagesBtn.style.backgroundColor = isReady ? 'var(--c-dark-blue)' : 'var(--c-gray)';
        if(isReady) {
            confirmImagesBtn.classList.remove('cursor-not-allowed');
            confirmImagesBtn.classList.add('hover:brightness-95');
        } else {
            confirmImagesBtn.classList.add('cursor-not-allowed');
            confirmImagesBtn.classList.remove('hover:brightness-95');
            imageInfo.classList.add('hidden');
        }
    };
    
    const handleFileSelection = (e) => {
        const input = e.target;
        const files = input.files;
        const inputId = input.id;

        if (!files || files.length === 0) {
            input.value = '';
            return;
        }

        if (inputId === 'folder-input') {
            selectedImages = [];
        }
        
        const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
        
        imageInfo.classList.remove('hidden');

        if (imageFiles.length === 0) {
            imageInfo.textContent = '画像ファイルが見つかりませんでした。';
            input.value = '';
            return;
        }

        imageInfo.textContent = `${imageFiles.length}枚の画像を読み込み中...`;
        
        const readerPromises = imageFiles.map(file => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(e);
                reader.readAsDataURL(file);
            });
        });

        Promise.all(readerPromises).then(results => {
            const uniqueNewImages = results.filter(src => !selectedImages.includes(src));
            selectedImages.push(...uniqueNewImages);

            updateImagePreview();
            imageInfo.textContent = `${selectedImages.length}枚の画像を選択しました。`;
            updateStep1ConfirmButtonState();
        }).catch(error => {
            console.error("画像読み込みエラー:", error);
            imageInfo.textContent = '画像の読み込みに失敗しました。';
        }).finally(() => {
            input.value = ''; 
        });
    };
    
    const removeImage = (srcToRemove) => {
        playSfx(sfx.button);
        selectedImages = selectedImages.filter(src => src !== srcToRemove);
        updateImagePreview();
        updateStep1ConfirmButtonState();
        if (selectedImages.length > 0) {
            imageInfo.textContent = `${selectedImages.length}枚の画像を選択しました。`;
        }
    };

    const updateImagePreview = () => {
        imagePreviewArea.innerHTML = '';
        if (selectedImages.length > 0) {
            imagePreviewArea.classList.remove('hidden');
            selectedImages.forEach(src => {
                const wrapper = document.createElement('div');
                wrapper.className = 'relative';

                const img = document.createElement('img');
                img.src = src;
                img.className = 'w-16 h-16 object-cover rounded-lg shadow-md';
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'absolute top-0 left-0 w-5 h-5 bg-[var(--c-dark-blue)] text-white rounded-full flex items-center justify-center text-sm font-bold -translate-x-1/4 -translate-y-1/4 hover:brightness-125 transition-all';
                removeBtn.innerHTML = '&times;';
                removeBtn.title = '画像を削除';
                removeBtn.onclick = (e) => {
                    e.preventDefault();
                    removeImage(src);
                };

                wrapper.appendChild(img);
                wrapper.appendChild(removeBtn);
                imagePreviewArea.appendChild(wrapper);
            });
        } else {
            imagePreviewArea.classList.add('hidden');
        }
    };

    folderInput.addEventListener('change', (e) => { playSfx(sfx.button); handleFileSelection(e); });
    filesInput.addEventListener('change', (e) => { playSfx(sfx.button); handleFileSelection(e); });
    confirmImagesBtn.addEventListener('click', () => { playSfx(sfx.button); showStep(2); });

    // ========== ステップ2: 表示方法選択 ==========
    const updateFitButtons = () => {
        const isCover = imageFit === 'cover';
        fitCoverBtn.style.backgroundColor = isCover ? 'var(--c-cyan)' : 'var(--c-gray)';
        fitContainBtn.style.backgroundColor = !isCover ? 'var(--c-cyan)' : 'var(--c-gray)';
    };

    fitCoverBtn.addEventListener('click', () => { playSfx(sfx.button); imageFit = 'cover'; updateFitButtons(); });
    fitContainBtn.addEventListener('click', () => { playSfx(sfx.button); imageFit = 'contain'; updateFitButtons(); });
    confirmFitBtn.addEventListener('click', () => { playSfx(sfx.button); showStep(3); });
    backToStep1Btn.addEventListener('click', () => { playSfx(sfx.button); showStep(1); });

    // ========== ステップ3: 難易度選択 ==========
    const updateDifficultyButtons = () => {
        const isEasy = difficulty === 'easy';
        easyModeBtn.style.backgroundColor = isEasy ? 'var(--c-cyan)' : 'var(--c-gray)';
        hardModeBtn.style.backgroundColor = !isEasy ? 'var(--c-cyan)' : 'var(--c-gray)';
        easyModeBtn.style.color = 'white';
        hardModeBtn.style.color = 'white';
    };

    easyModeBtn.addEventListener('click', () => { playSfx(sfx.button); difficulty = 'easy'; updateDifficultyButtons(); });
    hardModeBtn.addEventListener('click', () => { playSfx(sfx.button); difficulty = 'hard'; updateDifficultyButtons(); });
    backToStep2Btn.addEventListener('click', () => { playSfx(sfx.button); showStep(2); });
    startGameBtn.addEventListener('click', () => { playSfx(sfx.button); startGame(); });

    // ========== ゲーム開始・進行ロジック ==========
    const startGame = () => {
        gameBoard.innerHTML = '';
        resetTurn();
        pairsFound = 0;
        totalPairs = selectedImages.length;
        let gameImages = [...selectedImages, ...selectedImages];
        for (let i = gameImages.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [gameImages[i], gameImages[j]] = [gameImages[j], gameImages[i]];
        }
        setupGameBoard(gameImages);
        showScreen('game');
    };
    
    const setupGameBoard = (images) => {
        const numCards = images.length;
        const columns = Math.ceil(Math.sqrt(numCards));
        gameBoard.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
        gameBoard.innerHTML = '';
        images.forEach((imageSrc) => {
            const card = document.createElement('div');
            card.style.width = `${currentCardSize}px`;
            card.style.height = `${currentCardSize}px`;
            card.dataset.id = imageSrc;
            card.classList.add('card', 'relative', 'cursor-pointer', 'rounded-xl', 'shadow-lg');
            card.innerHTML = `
                <div class="card-face card-front absolute w-full h-full rounded-xl bg-gradient-to-br from-[var(--c-cyan)] to-[var(--c-dark-blue)] flex items-center justify-center p-2">
                    <span class="font-pop text-4xl text-white drop-shadow-md">?</span>
                </div>
                <div class="card-face card-back absolute w-full h-full rounded-xl bg-white p-1 flex items-center justify-center">
                    <img src="${imageSrc}" class="max-w-full max-h-full rounded-lg" style="object-fit: ${imageFit};" draggable="false">
                </div>
            `;
            if (difficulty === 'easy') card.classList.add('is-flipped');
            card.addEventListener('click', () => onCardClick(card));
            gameBoard.appendChild(card);
        });
    };

    const onCardClick = (card) => {
        if (lockBoard || card === firstCard || card.classList.contains('is-matched')) return;
        if (difficulty === 'hard') {
            if (card.classList.contains('is-flipped')) {
                card.classList.remove('is-flipped');
                setTimeout(() => playSfx(sfx.open), 200);
                firstCard = null;
                return;
            }
            card.classList.add('is-flipped');
            setTimeout(() => playSfx(sfx.open), 200);
        } else {
            playSfx(sfx.button);
            if (card.classList.contains('is-selected')) {
                 card.classList.remove('is-selected', 'ring-4', 'ring-offset-2', 'ring-[var(--c-cyan)]');
                 firstCard = null;
                 return;
            }
            card.classList.add('is-selected', 'ring-4', 'ring-offset-2', 'ring-[var(--c-cyan)]');
        }
        if (!firstCard) { firstCard = card; return; }
        secondCard = card;
        lockBoard = true;
        checkForMatch();
    };

    const checkForMatch = () => { (firstCard.dataset.id === secondCard.dataset.id) ? handleMatch() : handleMismatch(); };

    const handleMatch = () => {
        const sfxDelay = difficulty === 'hard' ? 800 : 500;
        setTimeout(() => { playSfx(sfx.pair); }, sfxDelay);
        pairsFound++;
        firstCard.classList.add('is-matched');
        secondCard.classList.add('is-matched');
        
        if (pairsFound === totalPairs) {
            setTimeout(() => {
                firstCard.style.visibility = 'hidden';
                secondCard.style.visibility = 'hidden';
                endGame();
            }, 1000);
            return;
        }

        if (difficulty === 'hard') {
            nextPairBtn.classList.remove('hidden');
        } else {
            setTimeout(() => {
                if (difficulty === 'easy') {
                    firstCard.classList.remove('is-selected', 'ring-4', 'ring-offset-2', 'ring-[var(--c-cyan)]');
                    secondCard.classList.remove('is-selected', 'ring-4', 'ring-offset-2', 'ring-[var(--c-cyan)]');
                }
                firstCard.style.visibility = 'hidden';
                secondCard.style.visibility = 'hidden';
                resetTurn();
            }, 1000);
        }
    };

    const handleMismatch = () => {
        const sfxDelay = difficulty === 'hard' ? 800 : 500;
        setTimeout(() => { playSfx(sfx.fail); }, sfxDelay);

        if (difficulty === 'hard') {
            returnCardsBtn.classList.remove('hidden');
        } else {
            setTimeout(() => {
                firstCard.classList.remove('is-selected', 'ring-4', 'ring-offset-2', 'ring-[var(--c-cyan)]');
                secondCard.classList.remove('is-selected', 'ring-4', 'ring-offset-2', 'ring-[var(--c-cyan)]');
                resetTurn();
            }, 1200);
        }
    };

    const resetTurn = () => { [firstCard, secondCard, lockBoard] = [null, null, false]; };
    
    const resetGameStates = () => {
        showStep(1);
        gameBoard.innerHTML = '';
        selectedImages = [];
        imageFit = 'cover';
        difficulty = 'easy';
        updateFitButtons();
        updateDifficultyButtons();
        resetTurn();
        pairsFound = 0; totalPairs = 0;
        imagePreviewArea.innerHTML = '';
        imagePreviewArea.classList.add('hidden');
        imageInfo.textContent = '';
        imageInfo.classList.add('hidden');
        folderInput.value = '';
        filesInput.value = '';
        nextPairBtn.classList.add('hidden');
        returnCardsBtn.classList.add('hidden');
        updateStep1ConfirmButtonState();
    };

    const endGame = () => {
        playSfx(sfx.clear);
        setTimeout(() => {
            const modalContent = clearModal.querySelector('div');
            if (clearModal) clearModal.classList.remove('hidden');
            if(modalContent){
                setTimeout(() => {
                    modalContent.classList.remove('scale-75', 'opacity-0');
                    modalContent.classList.add('scale-100', 'opacity-100');
                }, 50);
            }
        }, 500);
    };

    // ========== イベントリスナー設定 ==========
    backToTitleBtn.addEventListener('click', () => { playSfx(sfx.button); init(); });
    backToTitleFromClearBtn.addEventListener('click', () => {
        playSfx(sfx.button);
        const modalContent = clearModal.querySelector('div');
        if (modalContent) modalContent.classList.add('scale-75', 'opacity-0');
        setTimeout(() => { if (clearModal) clearModal.classList.add('hidden'); init(); }, 300);
    });
    
    muteBtn.addEventListener('click', () => {
        if (!isMuted) playSfx(sfx.button);
        toggleMute();
    });

    nextPairBtn.addEventListener('click', () => {
        playSfx(sfx.button);
        if(firstCard && secondCard){
            firstCard.style.visibility = 'hidden';
            secondCard.style.visibility = 'hidden';
        }
        nextPairBtn.classList.add('hidden');
        resetTurn();
    });

    returnCardsBtn.addEventListener('click', () => {
        playSfx(sfx.button);
        if(firstCard && secondCard){
            firstCard.classList.remove('is-flipped');
            secondCard.classList.remove('is-flipped');
        }
        returnCardsBtn.classList.add('hidden');
        resetTurn();
    });

    const adjustCardSize = (delta) => {
        playSfx(sfx.button);
        const newSize = currentCardSize + delta;
        if (newSize >= 48 && newSize <= 256) {
            currentCardSize = newSize;
            const cards = gameBoard.querySelectorAll('.card');
            cards.forEach(card => {
                card.style.width = `${currentCardSize}px`;
                card.style.height = `${currentCardSize}px`;
            });
        }
    };
    zoomInBtn.addEventListener('click', () => adjustCardSize(16));
    zoomOutBtn.addEventListener('click', () => adjustCardSize(-16));

    init();
});
</script>

</body>
</html>